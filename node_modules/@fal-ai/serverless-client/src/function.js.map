{"version":3,"file":"function.js","sourceRoot":"","sources":["../../../../libs/client/src/function.ts"],"names":[],"mappings":"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","sourcesContent":["import { getTemporaryAuthToken } from './auth';\nimport { dispatchRequest } from './request';\nimport { storageImpl } from './storage';\nimport { FalStream } from './streaming';\nimport { EnqueueResult, QueueStatus, RequestLog } from './types';\nimport { ensureAppIdFormat, isUUIDv4, isValidUrl, parseAppId } from './utils';\n\n/**\n * The function input and other configuration when running\n * the function, such as the HTTP method to use.\n */\ntype RunOptions<Input> = {\n  /**\n   * The path to the function, if any. Defaults to ``.\n   * @deprecated Pass the path as part of the app id itself, e.g. `fal-ai/sdxl/image-to-image`\n   */\n  readonly path?: string;\n\n  /**\n   * The function input. It will be submitted either as query params\n   * or the body payload, depending on the `method`.\n   */\n  readonly input?: Input;\n\n  /**\n   * The HTTP method, defaults to `post`;\n   */\n  readonly method?: 'get' | 'post' | 'put' | 'delete' | string;\n\n  /**\n   * If `true`, the function will automatically upload any files\n   * (i.e. instances of `Blob`).\n   *\n   * This is enabled by default. You can disable it by setting it to `false`.\n   */\n  readonly autoUpload?: boolean;\n};\n\ntype ExtraOptions = {\n  /**\n   * If `true`, the function will use the queue to run the function\n   * asynchronously and return the result in a separate call. This\n   * influences how the URL is built.\n   */\n  readonly subdomain?: string;\n\n  /**\n   * The query parameters to include in the URL.\n   */\n  readonly query?: Record<string, string>;\n};\n\n/**\n * Builds the final url to run the function based on its `id` or alias and\n * a the options from `RunOptions<Input>`.\n *\n * @private\n * @param id the function id or alias\n * @param options the run options\n * @returns the final url to run the function\n */\nexport function buildUrl<Input>(\n  id: string,\n  options: RunOptions<Input> & ExtraOptions = {}\n): string {\n  const method = (options.method ?? 'post').toLowerCase();\n  const path = (options.path ?? '').replace(/^\\//, '').replace(/\\/{2,}/, '/');\n  const input = options.input;\n  const params = {\n    ...(options.query || {}),\n    ...(method === 'get' ? input : {}),\n  };\n\n  const queryParams =\n    Object.keys(params).length > 0\n      ? `?${new URLSearchParams(params).toString()}`\n      : '';\n  const parts = id.split('/');\n\n  // if a fal url is passed, just use it\n  if (isValidUrl(id)) {\n    const url = id.endsWith('/') ? id : `${id}/`;\n    return `${url}${path}${queryParams}`;\n  }\n\n  // TODO remove this after some time, fal.run should be preferred\n  if (parts.length === 2 && isUUIDv4(parts[1])) {\n    const host = 'gateway.shark.fal.ai';\n    return `https://${host}/trigger/${id}/${path}${queryParams}`;\n  }\n\n  const appId = ensureAppIdFormat(id);\n  const subdomain = options.subdomain ? `${options.subdomain}.` : '';\n  const url = `https://${subdomain}fal.run/${appId}/${path}`;\n  return `${url.replace(/\\/$/, '')}${queryParams}`;\n}\n\nexport async function send<Input, Output>(\n  id: string,\n  options: RunOptions<Input> & ExtraOptions = {}\n): Promise<Output> {\n  const input =\n    options.input && options.autoUpload !== false\n      ? await storageImpl.transformInput(options.input)\n      : options.input;\n  return dispatchRequest<Input, Output>(\n    options.method ?? 'post',\n    buildUrl(id, options),\n    input as Input\n  );\n}\n\n/**\n * Runs a fal serverless function identified by its `id`.\n *\n * @param id the registered function revision id or alias.\n * @returns the remote function output\n */\nexport async function run<Input, Output>(\n  id: string,\n  options: RunOptions<Input> = {}\n): Promise<Output> {\n  return send(id, options);\n}\n\nconst DEFAULT_POLL_INTERVAL = 500;\n\n/**\n * Subscribes to updates for a specific request in the queue.\n *\n * @param id - The ID or URL of the function web endpoint.\n * @param options - Options to configure how the request is run and how updates are received.\n * @returns A promise that resolves to the result of the request once it's completed.\n */\nexport async function subscribe<Input, Output>(\n  id: string,\n  options: RunOptions<Input> & QueueSubscribeOptions = {}\n): Promise<Output> {\n  const { request_id: requestId } = await queue.submit(id, options);\n  if (options.onEnqueue) {\n    options.onEnqueue(requestId);\n  }\n  if (options.mode === 'streaming') {\n    const status = await queue.streamStatus(id, {\n      requestId,\n      logs: options.logs,\n    });\n    const logs: RequestLog[] = [];\n    status.on('message', (data: QueueStatus) => {\n      if (options.onQueueUpdate) {\n        // accumulate logs to match previous polling behavior\n        if (\n          'logs' in data &&\n          Array.isArray(data.logs) &&\n          data.logs.length > 0\n        ) {\n          logs.push(...data.logs);\n        }\n        options.onQueueUpdate('logs' in data ? { ...data, logs } : data);\n      }\n    });\n    await status.done();\n    return queue.result<Output>(id, { requestId });\n  }\n  // default to polling until status streaming is stable and faster\n  return new Promise<Output>((resolve, reject) => {\n    let timeoutId: ReturnType<typeof setTimeout>;\n    const pollInterval = options.pollInterval ?? DEFAULT_POLL_INTERVAL;\n    const poll = async () => {\n      try {\n        const requestStatus = await queue.status(id, {\n          requestId,\n          logs: options.logs ?? false,\n        });\n        if (options.onQueueUpdate) {\n          options.onQueueUpdate(requestStatus);\n        }\n        if (requestStatus.status === 'COMPLETED') {\n          clearTimeout(timeoutId);\n          try {\n            const result = await queue.result<Output>(id, { requestId });\n            resolve(result);\n          } catch (error) {\n            reject(error);\n          }\n          return;\n        }\n        timeoutId = setTimeout(poll, pollInterval);\n      } catch (error) {\n        clearTimeout(timeoutId);\n        reject(error);\n      }\n    };\n    poll().catch(reject);\n  });\n}\n\n/**\n * Options for subscribing to the request queue.\n */\ntype QueueSubscribeOptions = {\n  /**\n   * The mode to use for subscribing to updates. It defaults to `polling`.\n   * You can also use client-side streaming by setting it to `streaming`.\n   *\n   * **Note:** Streaming is currently experimental and once stable, it will\n   * be the default mode.\n   *\n   * @see pollInterval\n   */\n  mode?: 'polling' | 'streaming';\n\n  /**\n   * Callback function that is called when a request is enqueued.\n   * @param requestId - The unique identifier for the enqueued request.\n   */\n  onEnqueue?: (requestId: string) => void;\n\n  /**\n   * Callback function that is called when the status of the queue changes.\n   * @param status - The current status of the queue.\n   */\n  onQueueUpdate?: (status: QueueStatus) => void;\n\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n} & (\n  | {\n      mode?: 'polling';\n      /**\n       * The interval (in milliseconds) at which to poll for updates.\n       * If not provided, a default value of `500` will be used.\n       *\n       * This value is ignored if `mode` is set to `streaming`.\n       */\n      pollInterval?: number;\n    }\n  | {\n      mode: 'streaming';\n    }\n);\n\n/**\n * Options for submitting a request to the queue.\n */\ntype SubmitOptions<Input> = RunOptions<Input> & {\n  /**\n   * The URL to send a webhook notification to when the request is completed.\n   * @see WebHookResponse\n   */\n  webhookUrl?: string;\n};\n\ntype BaseQueueOptions = {\n  /**\n   * The unique identifier for the enqueued request.\n   */\n  requestId: string;\n};\n\ntype QueueStatusOptions = BaseQueueOptions & {\n  /**\n   * If `true`, the response will include the logs for the request.\n   * Defaults to `false`.\n   */\n  logs?: boolean;\n};\n\n/**\n * Represents a request queue with methods for submitting requests,\n * checking their status, retrieving results, and subscribing to updates.\n */\ninterface Queue {\n  /**\n   * Submits a request to the queue.\n   *\n   * @param endpointId - The ID or URL of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of enqueuing the request.\n   */\n  submit<Input>(\n    endpointId: string,\n    options: SubmitOptions<Input>\n  ): Promise<EnqueueResult>;\n\n  /**\n   * Retrieves the status of a specific request in the queue.\n   *\n   * @param endpointId - The ID or URL of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the status of the request.\n   */\n  status(endpointId: string, options: QueueStatusOptions): Promise<QueueStatus>;\n\n  /**\n   * Retrieves the result of a specific request from the queue.\n   *\n   * @param endpointId - The ID or URL of the function web endpoint.\n   * @param options - Options to configure how the request is run.\n   * @returns A promise that resolves to the result of the request.\n   */\n  result<Output>(\n    endpointId: string,\n    options: BaseQueueOptions\n  ): Promise<Output>;\n\n  /**\n   * @deprecated Use `fal.subscribe` instead.\n   */\n  subscribe<Input, Output>(\n    endpointId: string,\n    options: RunOptions<Input> & QueueSubscribeOptions\n  ): Promise<Output>;\n\n  streamStatus(\n    endpointId: string,\n    options: QueueStatusOptions\n  ): Promise<FalStream<unknown, QueueStatus>>;\n}\n\n/**\n * The fal run queue module. It allows to submit a function to the queue and get its result\n * on a separate call. This is useful for long running functions that can be executed\n * asynchronously and not .\n */\nexport const queue: Queue = {\n  async submit<Input>(\n    endpointId: string,\n    options: SubmitOptions<Input>\n  ): Promise<EnqueueResult> {\n    const { webhookUrl, path = '', ...runOptions } = options;\n    return send(endpointId, {\n      ...runOptions,\n      subdomain: 'queue',\n      method: 'post',\n      path: path,\n      query: webhookUrl ? { fal_webhook: webhookUrl } : undefined,\n    });\n  },\n  async status(\n    endpointId: string,\n    { requestId, logs = false }: QueueStatusOptions\n  ): Promise<QueueStatus> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : '';\n    return send(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: 'queue',\n      method: 'get',\n      path: `/requests/${requestId}/status`,\n      input: {\n        logs: logs ? '1' : '0',\n      },\n    });\n  },\n  async streamStatus(\n    endpointId: string,\n    { requestId, logs = false }: QueueStatusOptions\n  ): Promise<FalStream<unknown, QueueStatus>> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : '';\n    const token = await getTemporaryAuthToken(endpointId);\n    const url = buildUrl(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: 'queue',\n      path: `/requests/${requestId}/status/stream`,\n    });\n\n    const queryParams = new URLSearchParams({\n      fal_jwt_token: token,\n      logs: logs ? '1' : '0',\n    });\n\n    return new FalStream<unknown, QueueStatus>(`${url}?${queryParams}`, {\n      input: {},\n      method: 'get',\n    });\n  },\n  async result<Output>(\n    endpointId: string,\n    { requestId }: BaseQueueOptions\n  ): Promise<Output> {\n    const appId = parseAppId(endpointId);\n    const prefix = appId.namespace ? `${appId.namespace}/` : '';\n    return send(`${prefix}${appId.owner}/${appId.alias}`, {\n      subdomain: 'queue',\n      method: 'get',\n      path: `/requests/${requestId}`,\n    });\n  },\n  subscribe,\n};\n"]}